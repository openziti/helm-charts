<!-- README.md generated by helm-docs from README.md.gotmpl -->

{{ template "chart.header" . }}
{{ template "chart.deprecationWarning" . }}

{{ template "chart.badgesSection" . }}

{{ template "chart.description" . }}

{{ template "chart.homepageLine" . }}

{{ template "chart.maintainersSection" . }}

{{ template "chart.sourcesSection" . }}

{{ template "chart.requirementsSection" . }}

## Requirements

Add the OpenZiti Charts Repo with Helm.

```bash
helm repo add openziti https://docs.openziti.io/helm-charts/
```

This chart runs a Ziti controller in Kubernetes. 

### Mutual TLS

Ziti's TLS server ports must be published with a TLS passthrough to allow the controller to validate the client certificates from routers and identities. This may be done with a Traefik IngressRouteTCP, Gateway API TLSRoute, Ingress, NodePort, LoadBalancer, etc. The ctrl plane and management API share the client API's TLS listener by default, so there's one TCP port by default that must be published with TLS passthrough enabled.

### Certificates

It is not normally necessary to obtain publicly trusted certificates for Ziti's TLS servers. Ziti manages the trust relationships between the controller and routers and clients independent of the web's root authorities. See the [Alternative Web Server Certificates](#alternative-web-server-certificates) section for more information.

### Deployment

The deployment must have exactly one replica.

### Custom Resources

This chart requires the custom resources provided by [cert-manager](https://cert-manager.io/docs/installation/) and [trust-manager](https://cert-manager.io/docs/projects/trust-manager/#installation), i.e., Issuer, Certificate, and Bundle. It is a limitation of Trust Manager to have one instance per cluster and one namespace from which trust Bundle inputs may be sourced, so a single Ziti controller may occupy the cluster unless your use case allows for controllers from multiple networks to share a namespace. You must set the Trust Manager's "trust namespace" to the namespace of the Ziti controller so that it will be able to compose a trust Bundle resource from Ziti's root CA cert(s).

```bash
helm repo add jetstack https://charts.jetstack.io

helm upgrade --install cert-manager jetstack/cert-manager \
    --namespace cert-manager --create-namespace \
    --set crds.enabled=true

kubectl create namespace ziti
helm upgrade --install trust-manager jetstack/trust-manager \
    --namespace cert-manager \
    --set crds.keep=false \
    --set app.trust.namespace=ziti
```

### Breaking Change: Version 3 PKI Consolidation

Version 3 of this chart consolidates the PKI architecture into a single root of trust. This is a breaking change that requires a controller restart and retires certain cert-manager resources, but it is expected to work without adjusting chart input values and does not require re-enrolling routers or identities.

**What Changed**

- **Before (v2):** The controller used separate PKI roots for the control plane, web/client APIs, and edge enrollment, with separate intermediate issuers for each PKI.
- **After (v3):** Only the edge PKI root and intermediate issuers are used. The separate control plane and web root and intermediate issuers are retired. All leaf certificates for the control plane, web/client APIs, and edge enrollments are now issued by the edge signer intermediate issuer, which is itself issued by the edge root issuer (the cluster's shared root of trust).

**Upgrade Process**

1. Back up the controller database before proceeding.
1. Upgrade the controller's Helm release with a chart version constraint that allows v3, e.g., `^3.0.0`.
1. Wait for the web identity certificate to be ready:

    ```bash
    kubectl wait certificate.cert-manager.io ziti-controller-web-identity-cert \
        --namespace ziti \
        --for condition=Ready=True \
        --timeout 120s
    ```

1. Restart the controller and all routers to pick up the latest certificates:

    ```bash
    kubectl rollout restart deployment ziti-controller -n ziti
    kubectl rollout restart deployment ziti-router -n ziti
    ```

**Alternative Root Issuer**

It is still possible to rebase your edge PKI on an existing, alternative root issuer by configuring `edgeSignerPki.alternativeIssuer`. However, web and control plane identity certificates are always issued by the edge signer intermediate in the v3 chart.

For detailed upgrade instructions, including upgrading to HA, see the [internal documentation](https://github.com/netfoundry/k8s-on-prem-installations/blob/main/docs/ha_upgrade.md).

## NodePort Service Example

| Value | Description |
|-------|-------------|
|clientApi.advertisedHost|the address that clients and routers will use to reach this controller|
|clientApi.advertisedPort|the TCP port associated with the advertisedHost|
|clientApi.service.type|the service type for the client API and router control plane|

```bash
helm upgrade ziti-controller openziti/ziti-controller \
    --install \
    --namespace ziti \
    --create-namespace \
    --set clientApi.advertisedHost=ctrl1.ziti.example.com \
    --set clientApi.advertisedPort=32171 \
    --set clientApi.service.type=NodePort
```

Here's the YAML representation of the same set of input values.

```yaml
clientApi:
    advertisedHost: ctrl1.ziti.example.com
    advertisedPort: 32171
    service:
        type: NodePort
```

Visit the Ziti Administration Console (ZAC): https://ctrl1.ziti.example.com:32171/zac/

Log in with the `ziti` CLI.

<!-- {% raw %} "raw" escapes this code block's handlebars from GH Pages Jekyll, and {{``}} escapes the Go template from helm-docs -->
```bash
ziti edge login ctrl1.ziti.example.com:32171 --yes --username admin --password $(
    kubectl -n ziti get secrets ziti-controller-admin-secret -o go-template='{{`{{index .data "admin-password" | base64decode }}`}}'
)
```
<!-- {% endraw %} -->

## Traefik Gateway API TLSRoute Example (Experimental)

Gateway API TLSRoute support is available in this chart, but remains experimental for Traefik deployments. Prefer IngressRouteTCP for production and long-lived environments.

```bash
helm upgrade ziti-controller openziti/ziti-controller \
    --install \
    --namespace ziti \
    --set clientApi.advertisedHost=ctrl1.ziti.example.com \
    --set clientApi.advertisedPort=443 \
    --set clientApi.service.type=ClusterIP \
    --set clientApi.gatewayTlsRoute.enabled=true \
    --set-json 'clientApi.gatewayTlsRoute.parentRefs=[{"name":"traefik-gateway","namespace":"traefik","sectionName":"websecure"}]'
```


## Traefik IngressRouteTCP Example

Recommended default: use Traefik IngressRouteTCP for TLS passthrough.

This example creates a Traefik IngressRouteTCP for the client API's ClusterIP service.

```bash
helm upgrade ziti-controller openziti/ziti-controller \
    --install \
    --namespace ziti \
    --create-namespace \
    --set clientApi.advertisedHost=ctrl1.ziti.example.com \
    --set clientApi.advertisedPort=443 \
    --set clientApi.service.type=ClusterIP \
    --set clientApi.traefikTcpRoute.enabled=true
```

Or use the provided values file:

```bash
helm upgrade ziti-controller openziti/ziti-controller \
    --install \
    --namespace ziti \
    --values values-traefik-ingressroutetcp.yaml
```

Visit the Ziti Administration Console (ZAC): https://ctrl1.ziti.example.com/zac/

Log in with the `ziti` CLI.

<!-- {% raw %} "raw" escapes this code block's handlebars from GH Pages Jekyll, and {{``}} escapes the Go template from helm-docs -->
```bash
ziti edge login ctrl1.ziti.example.com:443 --yes --username admin --password $(
    kubectl -n ziti get secrets ziti-controller-admin-secret -o go-template='{{`{{index .data "admin-password" | base64decode }}`}}'
)
```
<!-- {% endraw %} -->

## Admin User and Password

A default admin user and password will be generated and saved to a secret during installation. The credentials can be retrieved using this command.

<!-- {% raw %} "raw" escapes this code block's handlebars from GH Pages Jekyll, and {{``}} escapes the Go template from helm-docs -->
```bash
kubectl get secret \
    -n ziti ziti-controller-admin-secret \
    -o go-template='{{`{{range $k,$v := .data}}{{printf "%s: " $k}}{{if not $v}}{{$v}}{{else}}{{$v | base64decode}}{{end}}{{"\n"}}{{end}}`}}'
```
<!-- {% endraw %} -->

## Extra Security for the Management API

You can split the client and management APIs into separate cluster services by setting `managementApi.service.enabled=true`. With this configuration, you'll have an additional cluster service named `{release}-mgmt` that is the management API, and the client API will not have management features.

This Helm chart's values allow for both operational scenarios: combined and split. The default choice is to expose the combined client and management APIs as the cluster service named `{release}-client`, which is convenient because you can use the `ziti` CLI immediately. For additional security, you may shelter the management API by splitting these two sets of features, exposing them as separate API servers. After the split, you can access the management API in several ways:

* deploy a tunneler to bind a Ziti service targeting `{release}-mgmt.{namespace}.svc:{port}`.
* `kubectl -n {namespace} port-forward deployments/{release}-mgmt 8443:{port}`

The web console (ZAC) is always bound to the same web listener as the management API, so you can access it at that `/zac/` path on the same URL.

## Advanced PKI

The default configuration generates a singular PKI root of trust for all the controller's servers and the edge signer CA. Optionally, you may provide the name of a cert-manager Issuer or ClusterIssuer to become the root of trust for the Ziti controller's identity.

Merge this with your Helm chart values file before installing or upgrading.

```yaml
ctrlPlane:
    issuer:
        kind: ClusterIssuer
        name: my-alternative-cluster-issuer
```

You may also configure the Ziti controller to use separate PKI roots of trust for its three main identities: control plane, edge signer, and web bindings.

For example, to use a separate CA for the edge signer function, merge this with your Helm chart values file before installing or upgrading.

```yaml
edgeSignerPki:
    enabled: true
```

## Prometheus Monitoring

This chart provides a default disabled `ziti-controller-prometheus` k8s service for prometheus,
which can be enabled with `prometheus.service.enabled`. Enabling it will create a prometheus ServiceMonitor
for configuring the prometheus endpoint. It is also important that you enable
`fabric.events.enabled` for getting a full set of metrics.

For more information, please check [here](https://openziti.io/docs/learn/core-concepts/metrics/prometheus/).

## Values Reference

{{ template "chart.valuesTable" . }}

## TODO's

* High availability clustered mode
* Deploy Prometheus scraper configuration when `prometheus.enabled = true`

## Alternative Web Server Certificates

The purpose of the `alt_server_certs` feature is to bind a publicly trusted server certificate to the controller's web listener. This is useful for publishing the controller's client API with a different DNS name for BrowZer and console clients that must verify the controller's identity with their OS trusted root store.

### Request an alternative server certificate from a cert-manager issuer

The most automatic way to bind an alt cert is the certManager mode provided by this chart. This example implies you have separately created a cert-manager ClusterIssuer named "cloudflare-dns01-issuer" that is able to obtain a certificate for the specified DNS name. If publishing the client API's alternative DNS name as a separate Ingress, you may reference that advertised host when requesting the alternative server certificate as shown here with an inline template to ensure they match. 

<!-- {% raw %} "raw" escapes this code block's handlebars from GH Pages Jekyll, and {{``}} escapes the Go template from helm-docs -->

```yaml
clientApi:
    advertisedHost: edge.ziti.example.com
    ingress:
        enabled: true
        ingressClassName: nginx
        annotations:
            kubernetes.io/ingress.allow-http: "false"
            nginx.ingress.kubernetes.io/ssl-passthrough: "true"
    service:
        enabled: true
        type: ClusterIP
    altDnsNames:
        - "alt-edge.ziti.example.com"  # configures SNI routing for ingresses

webBindingPki:
    enabled: true
    altServerCerts:
        - mode: certManager
            secretName: my-alt-server-cert
            altDnsNames:
                - "alt-edge.ziti.example.com"  # sets DNS SANs for the cert for SNI routing in controller process
            issuerRef:
                group: cert-manager.io
                kind: ClusterIssuer
                name: cloudflare-dns01-issuer
            mountPath: /etc/ziti/alt-server-cert
```
<!-- {% endraw %} -->

### Use an alternative certificate and key from a tls secret

The alternative server certificate and key may also be provided from a Kubernetes TLS secret. Declare the tls secret in the additionalVolumes section and reference it in the altServerCerts section.

<!-- {% raw %} "raw" escapes this code block's handlebars from GH Pages Jekyll, and {{``}} escapes the Go template from helm-docs -->
```yaml
additionalVolumes:
    - name: my-alt-server-cert
      volumeType: secret
      mountPath: /etc/ziti/my-alt-server-cert
      secretName: my-alt-server-cert

webBindingPki:
    altServerCerts:
        - mode: secret
          secretName: my-alt-server-cert
```
<!-- {% endraw %} -->

## Upgrading from Version 1 to Version 2

Version 2 of this chart introduced a breaking change requiring you to decouple cert-manager and trust-manager from the Ziti controller chart if they were previously installed as subcharts. This allows them to be upgraded and configured independently of the Ziti controller chart.

**Symptom**

> Error: Unable to continue with install: CustomResourceDefinition "certificaterequests.cert-manager.io" in namespace "" exists and cannot be imported into the current release: invalid ownership metadata; label validation error: missing key "app.kubernetes.io/managed-by": must be set to "Helm"; annotation validation error: missing key "meta.helm.sh/release-name": must be set to "cert-manager"; annotation validation error: missing key "meta.helm.sh/release-namespace": must be set to "cert-manager"

**Cause**

Cert Manager and Trust Manager are no longer included as subcharts, so upgrading the Ziti controller chart will delete the cert-manager and trust-manager Operators along with their respective CRDs and associated resources which are critical for the Ziti controller.

**Solution**

1. As with any controller upgrade, you are advised to back up the database before proceeding so that you will have the option to roll back to a snapshot prior to any irreversible database schema migrations that may occur during an upgrade.
1. Upgrade the Ziti controller Helm release to chart v2. This will temporarily uninstall the CM and TM Helm releases if they were originally installed as dependencies of the Ziti controller chart.
1. Install or upgrade as desired the cert-manager and trust-manager Helm releases (see [Custom Resources](#custom-resources) section above for an example that is compatible with this upgrade path).
1. If the cert-manager or trust-manager charts fail to install with the "symptom" above, then run the provided BASH script (`chown-cert-manager.bash`) to set the owner labels and annotations on existing cert-manager and trust-manager CRDs and resources.
1. Retry installing cert-manager and trust-manager Helm charts. When they are installed successfully, their respective Helm releases will own the CRDs that were annotated and labeled by the provided BASH script.

> [!IMPORTANT]
> You must use the same values for CM and TM Helm release names and namespaces when you run the provided script and when you re-install the cert-manager and trust-manager Helm charts.

Assuming your future CM release will be named "cert-manager," your future TM release will be named "trust-manager," and both will be installed in namespace "cert-manager," and your Ziti controller is installed in namespace "ziti," you can use these example values to run the provided script to pave the way to installing the version 2 ziti-controller chart, which will delete the cert-manager and trust-manager Operators, preserving the CRDs and their associated resources.

```bash
helm pull openziti/ziti-controller
tar -xvf ziti-controller-*.tgz
CM_NAMESPACE=cert-manager \
CM_RELEASE_NAME=cert-manager \
TM_NAMESPACE=cert-manager \
TM_RELEASE_NAME=trust-manager \
ZITI_NAMESPACE=ziti \
./ziti-controller/files/chown-cert-manager.bash
```

<!-- README.md generated by helm-docs from README.md.gotmpl -->
