<!-- README.md generated by helm-docs from README.md.gotmpl -->
# ziti-console

![Version: 0.2.0](https://img.shields.io/badge/Version-0.2.0-informational?style=flat-square) ![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square) ![AppVersion: latest](https://img.shields.io/badge/AppVersion-latest-informational?style=flat-square)

Deploy OpenZiti console as kubernetes service

## Add the OpenZiti Charts Repo to Helm

```bash
helm repo add openziti https://docs.openziti.io/helm-charts/
```

## Minimal Installation

This chart deploys a pod running `ziti-console`, [the OpenZiti console](https://github.com/openziti/ziti-console/).

After adding the charts repo to Helm then you may install the chart.

```bash
helm install \
  --namespace ziti-console --create-namespace --generate-name \
  openziti/ziti-console \
    --set service.type=LoadBalancer \
    --set service.advertisedPort=80
```

Although simple, using the LoadBalancer type may not be ideal for a variety of reasons. Here are some examples for creating an HTTP Ingress.

## Ingress-Nginx Sample Values

```yaml
ingress:
  enabled: true
  ingressClassName: nginx
  hosts:
    # DNS name for ingress on 80/tcp
    - host: # myziti-console.zitik8s

settings:
  edgeControllers:
    - name: Ziti Edge Mgmt API
      # URL of controller's mgmt API cluster service
      url: https://myziti-controller-client.ziti-controller.svc:443
      # or https://myziti-controller-mgmt.ziti-controller.svc:443 if mgmt API is separate
      default: true
```

## Traefik Sample Values

This is a minimal `values.yaml` sample for an k3s-enviroment using traefik as ingress loadbalancer:

```yaml
ingress:
  enabled: true
  hosts:
    # DNS name for ingress on 80/tcp
    - host: myziti-console.zitik8s
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
  labels:
    ingressMethod: traefik

settings:
  edgeControllers:
    - name: Ziti Edge Mgmt API
      # URL of controller's mgmt API cluster service
      url: https://myziti-controller-client.ziti-controller.svc:443
      # or https://myziti-controller-mgmt.ziti-controller.svc:443 if mgmt API is separate
      default: true
```

## TLS with Cert Manager

Cert Manager can provide a Let's Encrypt certificate for you, even a wildcard certificate with ACMEv2. As a prerequisite, you need a cert-manager Issuer for Let's Encrypt ([reference](https://cert-manager.io/docs/tutorials/acme/pomerium-ingress/#configure-lets-encrypt-issuer)). Here are example chart values showing annotations for cert-manager and ingress-nginx.

```yaml
ingress:
  ingressClassName: nginx
  annotations:
    cert-manager.io/cluster-issuer: my-letsencrypt-issuer
  hosts:
    - host: myziti-console.example.com
  tls:
    - hosts:
      - myziti-console.example.com
      secretName: myziti-console-tls-secret  # {helm release name}-tls-secret
```

## Values Reference

| Key | Type | Default | Description |
|-----|------|---------|-------------|
| affinity | object | `{}` | deployment pod node affinity |
| fullnameOverride | string | `""` | release fullname override |
| image.args | list | `[]` | app run command args |
| image.command | list | `["node","/usr/src/app/server.js","debug"]` | app run command |
| image.pullPolicy | string | `"Always"` | deployment image pull policy |
| image.pullSecrets | list | `[]` | app image registry credential |
| image.repository | string | `"openziti/zac"` | app container image to deploy  |
| ingress.annotations | object | `{}` | ingress annotations for the ingress controller |
| ingress.enabled | bool | `false` | create an ingress for the cluster service |
| ingress.hosts[0] | object | `{"host":null,"paths":[{"path":"/","pathType":"Prefix"}]}` | DNS names the ingress should recognize at the non-TLS listener |
| ingress.ingressClassName | string | `""` | "nginx" if using ingress-nginx |
| ingress.labels | object | `{}` | ingress labels |
| ingress.tls | list | `[]` | DNS names the ingress should recognize at the TLS listener and secret name |
| nameOverride | string | `""` | release name override |
| nodeSelector | object | `{}` | deployment pod node selector |
| podAnnotations | object | `{}` | annotations to apply to all pods |
| podSecurityContext | object | `{"fsGroup":1000,"runAsGroup":1000,"runAsUser":1000}` | deployment pod security context |
| replicas | int | `1` | deployment pod replicas |
| resources | object | `{}` | deployment container resources |
| securityContext | string | `nil` | deployment container security context |
| service.advertisedPort | int | `80` | port for the cluster service, load balancer, nodeport, and ingress to advertise |
| service.annotations | object | `{}` | cluster service annotations |
| service.containerPort | int | `1408` | port for the server to bind and cluster service to target |
| service.enabled | bool | `true` | create a cluster service for the deployment |
| service.labels | object | `{}` | cluster service labels |
| service.portName | string | `"http"` | symbolic name of the cluster service port |
| service.type | string | `"ClusterIP"` | choose ClusterIP, NodePort, or LoadBalancer |
| settings.edgeControllers | list | `[]` | Ziti Edge Mgmt APIs to pre-configure |
| settings.fabricControllers | list | `[]` | Ziti Fabric Mgmt APIs to pre-configure |
| tolerations | list | `[]` | deployment pod tolerations |

<!-- README.md generated by helm-docs from README.md.gotmpl -->
