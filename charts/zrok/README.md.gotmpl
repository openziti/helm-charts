<!-- README.md generated by helm-docs from README.md.gotmpl -->

{{ template "chart.header" . }}
{{ template "chart.deprecationWarning" . }}

{{ template "chart.badgesSection" . }}

{{ template "chart.description" . }}

{{ template "chart.homepageLine" . }}

{{ template "chart.maintainersSection" . }}

{{ template "chart.sourcesSection" . }}

{{ template "chart.requirementsSection" . }}

## Overview

## Requirements

### Add the OpenZiti Charts Repo to Helm

```bash
helm repo add openziti https://docs.openziti.io/helm-charts/
```

## Minimal Example with Nginx Ingress

This example does not configure TLS termination for the API or public shares, metrics, or limits. You must configure a
wildcard DNS record (A record) that resolve to the value of `ZROK_DNS_ZONE`. 

Use an `sslip.io` wildcard/zone like `zrok.192.168.49.2.sslip.io` for testing and tiny scale deployments if you
want to avoid setting up DNS. This works with any IP address.

```bash
ZROK_DNS_ZONE=zrok.example.com
ZITI_NAMESPACE=miniziti
ZITI_MGMT_API_HOST=ziti-controller-client.${ZITI_NAMESPACE}.svc.cluster.local
ZITI_PWD=$(kubectl -n "${ZITI_NAMESPACE}" get secrets "ziti-controller-admin-secret" \
    --output go-template='{{"{{"}}index .data "admin-password" | base64decode{{"}}"}}')

helm upgrade \
    --install \
    --namespace zrok --create-namespace \
    --values https://openziti.io/helm-charts/charts/zrok/values-ingress-nginx.yaml \
    --set "ziti.advertisedHost=${ZITI_MGMT_API_HOST}" \
    --set "ziti.password=${ZITI_PWD}" \
    --set "dnsZone=${ZROK_DNS_ZONE}" \
    --set "controller.ingress.hosts[0]=api.${ZROK_DNS_ZONE}" \
    zrok openziti/zrok
```

## TLS termination with Nginx

One way to terminate TLS with Nginx is to use Cert Manager. Cert Manager will issue a certificate, store it in the specified Secret, and configure the Ingress to use the certificate. This example shows the default behavior to use the Ingress host(s) as DNS SANs.

1. Install Cert Manager
1. Create a ClusterIssuer with a Let's Encrypt account and DNS challenge solver. Solving the DNS challenge is one way
    for Cert Manager to obtain a wildcard certificate which is necessary for zrok frontend's Ingress.
1. Set input values to annotate zrok's Ingresses with the name of the ClusterIssuer and specify a TLS secret name.

    ```bash
    helm upgrade zrok \
        --set "controller.ingress.annotations=cert-manager.io/cluster-issuer: letsencrypt-prod" \
        --set "controller.ingress.tlsSecretName=zrok-api-tls" \
        --set "frontend.ingress.annotations=cert-manager.io/cluster-issuer: letsencrypt-prod" \
        --set "frontend.ingress.tlsSecretName=zrok-wildcard-tls" \
        openziti/zrok
    ```

## Default account

The chart automatically creates a zrok account in the database. You can use the account token to enable a device environment with `zrok enable ${ZROK_ENABLE_TOKEN}` and you can log in to the zrok console with the username and password.

Get the zrok account token:

```bash
kubectl -n zrok \
    get secrets zrok-ziggy-account-token \
    -o go-template='{{`{{"\n"}}{{index .data "token" | base64decode }}{{"\n"}}`}}'
```

```text title="Output"

qEP0MNtA74T3

```

Get the zrok console login credentials:

```bash
kubectl -n zrok \
    get secrets zrok-ziggy-account-password \
    -o go-template='{{`{{"\n"}}{{range $k,$v := .data}}{{printf "%s: " $k}}{{if not $v}}{{$v}}{{else}}{{$v | base64decode}}{{end}}{{"\n"}}{{end}}`}}'
```

```text title="Output"

password: p7XWVyjHbMWazLc6PZveF2b8SB2wzxDD
username: ziggy@zrok.192.168.49.2.sslip.io

```

The zrok console URL depends on how you configure ingress. If you used the NGINX Ingress example, then you can query the URL with:

```bash
kubectl -n zrok get ingress zrok  
```

```text title="Output"
NAME   CLASS   HOSTS                             ADDRESS        PORTS   AGE
zrok   nginx   api.zrok.192.168.49.2.sslip.io    192.168.49.2   80      8m41s
```

## Values Reference

{{ template "chart.valuesTable" . }}

<!-- README.md generated by helm-docs from README.md.gotmpl -->
