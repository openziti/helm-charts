name: Test charts in minikube
on:
  workflow_dispatch:
  pull_request:
    paths:
      - .github/workflows/miniziti.yml
      - charts/ziti-controller/**
      - charts/ziti-router/**
      - charts/httpbin/**
      - charts/zrok/**

# cancel older, redundant runs of same workflow on same branch
concurrency:
  group: ${{ github.workflow }}-${{github.event_name}}-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

jobs:
  compute-k8s-matrix:
    name: compute Kubernetes version matrix
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.compute.outputs.matrix }}
    steps:
      - name: Compute top 3 Kubernetes minors from current stable
        id: compute
        shell: bash
        run: |
          set -euo pipefail
          stable="$(curl -fsSL https://dl.k8s.io/release/stable.txt)"
          stable="${stable#v}"
          major="${stable%%.*}"
          rest="${stable#*.}"
          minor="${rest%%.*}"

          m0="${major}.$((minor))"
          m1="${major}.$((minor - 1))"
          m2="${major}.$((minor - 2))"

          matrix_json=$(jq -cn --arg m0 "$m0" --arg m1 "$m1" --arg m2 "$m2" '{"kubernetes_minor": [$m0, $m1, $m2]}')
          echo "matrix=${matrix_json}" >> "$GITHUB_OUTPUT"

  miniziti:
    needs: compute-k8s-matrix
    name: deploy to minikube ${{ matrix.kubernetes_minor }}
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: true
      matrix: ${{ fromJson(needs.compute-k8s-matrix.outputs.matrix) }}
    env:
      ZITI_NAMESPACE: miniziti
      ZITI_CLI_VERSION: 1.7.0
    steps:
      - name: Checkout workspace
        uses: actions/checkout@v4

      - name: Resolve latest patch for Kubernetes minor
        id: resolve_k8s
        shell: bash
        run: |
          echo "kubernetes_version=$(curl -fsSL https://dl.k8s.io/release/stable-${{ matrix.kubernetes_minor }}.txt)" >> "$GITHUB_OUTPUT"

      - name: Start minikube
        uses: medyagh/setup-minikube@v0.0.20
        with:
          start-args: --profile ${{ env.ZITI_NAMESPACE }} --kubernetes-version=${{ steps.resolve_k8s.outputs.kubernetes_version }}

      - name: install ziti cli
        uses: supplypike/setup-bin@v5
        with:
          uri: https://github.com/openziti/ziti/releases/download/v${{ env.ZITI_CLI_VERSION }}/ziti-linux-amd64-${{ env.ZITI_CLI_VERSION }}.tar.gz
          name: ziti
          version: ${{ env.ZITI_CLI_VERSION }}

      # this is the kubernetes quickstart script from
      # https://openziti.io/docs/learn/quickstarts/network/local-kubernetes
      - name: install miniziti
        uses: supplypike/setup-bin@v5
        with:
          # uri: https://get.openziti.io/miniziti.bash
          uri: https://raw.githubusercontent.com/openziti/ziti/d1cdb171ed59242cd232ac6da4b75da16110bd64/quickstart/kubernetes/miniziti.bash
          # uri: https://raw.githubusercontent.com/openziti/ziti/<testing ref>/quickstart/kubernetes/miniziti.bash
          name: miniziti
          version: quickstartrelease

      - name: Select test mode
        id: mode
        shell: bash
        run: |
          if [[ "${{ vars.SKIP_MINIKUBE_LATEST_CHARTS }}" == "true" ]]; then
            echo "run_baseline=false" >> "$GITHUB_OUTPUT"
            echo "Running upgrade-only path"
          else
            echo "run_baseline=true" >> "$GITHUB_OUTPUT"
            echo "Running baseline+upgrade path"
          fi

      - name: Install Loki for log aggregation
        run: |
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update
          helm upgrade --install loki grafana/loki-stack \
            --namespace loki-stack \
            --create-namespace \
            --set loki.auth_enabled=false \
            --set promtail.enabled=true \
            --set grafana.enabled=false \
            --set test.enabled=false \
            --wait --timeout 120s

      - name: Run miniziti with latest release charts
        if: steps.mode.outputs.run_baseline == 'true'
        run: miniziti start --no-hosts --verbose
        env:
          MINIZITI_TIMEOUT_SECS: 300

      - name: Find miniziti ingress zone (initial)
        if: steps.mode.outputs.run_baseline == 'true'
        id: ingress_zone_initial
        run: |
          echo "ingress_zone=$(miniziti kubectl get configmap miniziti-config -n ${ZITI_NAMESPACE} -o jsonpath='{.data.ingress-zone}')" >> $GITHUB_OUTPUT

      - name: Find the ziti admin password (initial)
        if: steps.mode.outputs.run_baseline == 'true'
        id: get_ziti_pwd_initial
        run: |
          miniziti kubectl get secrets "ziti-controller-admin-secret" \
            --output go-template='{{index .data "admin-password" | base64decode }}' \
            | xargs -Iadmin_password echo "ZITI_PWD=admin_password" >> $GITHUB_OUTPUT

      - name: Enroll client identity
        if: steps.mode.outputs.run_baseline == 'true'
        run: >
          ziti edge enroll
          --jwt ~/.local/state/miniziti/profiles/${ZITI_NAMESPACE}/identities/${ZITI_NAMESPACE}-client.jwt
          --out ~/.local/state/miniziti/profiles/${ZITI_NAMESPACE}/identities/${ZITI_NAMESPACE}-client.json

      - name: Run client proxy
        if: steps.mode.outputs.run_baseline == 'true'
        run: >
          nohup ziti tunnel proxy "httpbin-service:4321"
          --identity ~/.local/state/miniziti/profiles/${ZITI_NAMESPACE}/identities/${ZITI_NAMESPACE}-client.json
          --verbose </dev/null &>/tmp/miniziti-client.log &

      - name: Wait for proxy to serve the httpbin service
        if: steps.mode.outputs.run_baseline == 'true'
        id: wait_for_proxy_initial
        continue-on-error: true
        uses: iFaxity/wait-on-action@v1
        with:
          resource: http://127.0.0.1:4321/get
          delay: 1000
          interval: 1000
          timeout: 20000

      - name: Send a POST request to the httpbin service
        if: steps.mode.outputs.run_baseline == 'true'
        id: test_httpbin_initial
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          curl -sSf -XPOST -F ziti=awesome http://127.0.0.1:4321/post > /tmp/httpbin-response.json
          AWESOME=$(jq -r '.form.ziti[0]' /tmp/httpbin-response.json)
          if [[ "$AWESOME" == "awesome" ]]; then
            echo "✓ Ziti is awesome!"
          else
            echo "✗ Got '$AWESOME' instead of 'awesome'" >&2
            exit 1
          fi

      - name: Start Loki port-forward for log queries
        if: steps.mode.outputs.run_baseline == 'true' && always()
        shell: bash
        run: |
          # Start port-forward in background
          miniziti kubectl port-forward -n loki-stack svc/loki 3100:3100 &
          echo "LOKI_PID=$!" >> $GITHUB_ENV
          sleep 5

      - name: Query Loki for post-install hook logs
        if: steps.mode.outputs.run_baseline == 'true' && always()
        shell: bash
        run: |
          echo "=========================================="
          echo "HTTPBin Post-Install Hook (from Loki)"
          echo "=========================================="
          
          # Query Loki for hook logs
          RESPONSE=$(curl -s "http://localhost:3100/loki/api/v1/query_range" \
            --data-urlencode "query={namespace=\"${ZITI_NAMESPACE}\",pod=~\".*post-install.*\"}" \
            --data-urlencode "start=$(date -u -d '10 minutes ago' +%s)000000000" \
            --data-urlencode "end=$(date -u +%s)000000000")
          
          echo "DEBUG: Loki response:"
          echo "$RESPONSE" | jq '.' || echo "Failed to parse JSON: $RESPONSE"
          
          # Extract log lines
          echo ""
          echo "Log lines:"
          echo "$RESPONSE" | jq -r '.data.result[].values[][1]' 2>/dev/null || echo "No logs found or failed to parse"
          
          echo ""
          echo "=========================================="
          echo "HTTPBin Application Logs (Initial Deploy)"
          echo "=========================================="
          
          # Wait for httpbin to start hosting the Ziti service
          echo "Waiting 10 seconds for httpbin to initialize..."
          sleep 10
          
          # Get httpbin pod logs
          HTTPBIN_POD=$(miniziti kubectl get pods -n ${ZITI_NAMESPACE} -l app.kubernetes.io/name=httpbin -o jsonpath='{.items[0].metadata.name}')
          if [[ -n "$HTTPBIN_POD" ]]; then
            echo "HTTPBin pod: $HTTPBIN_POD"
            miniziti kubectl logs -n ${ZITI_NAMESPACE} "$HTTPBIN_POD" --tail=50 || echo "Failed to get httpbin logs"
          else
            echo "WARNING: No httpbin pod found"
          fi

      - name: Install the zrok chart from the latest release
        if: steps.mode.outputs.run_baseline == 'true'
        shell: bash
        env:
          ZITI_MGMT_API_HOST: miniziti-controller.${{ steps.ingress_zone_initial.outputs.ingress_zone }}
          ZITI_PWD: ${{ steps.get_ziti_pwd_initial.outputs.ZITI_PWD }}
          ZROK_DNS_ZONE: ${{ steps.ingress_zone_initial.outputs.ingress_zone }}
        run: |
          helm upgrade \
            --install \
            --namespace zrok --create-namespace \
            --values ./charts/zrok/values-ingress-nginx.yaml \
            --set "ziti.advertisedHost=${ZITI_MGMT_API_HOST}" \
            --set "ziti.password=${ZITI_PWD}" \
            --set "dnsZone=${ZROK_DNS_ZONE}" \
            --set "controller.ingress.hosts[0]=zrok.${ZROK_DNS_ZONE}" \
            --set "test.enabled=false" \
            zrok openziti/zrok

      - name: Capture zrok controller and frontend logs (before upgrade)
        if: steps.mode.outputs.run_baseline == 'true'
        shell: bash
        run: |
          echo "=========================================="
          echo "Zrok Controller Logs (Before Upgrade)"
          echo "=========================================="
          
          # Wait for zrok pods to initialize
          echo "Waiting 10 seconds for zrok to initialize..."
          sleep 10
          
          # Get zrok controller logs
          ZROK_CTRL_POD=$(miniziti kubectl get pods -n zrok -l app.kubernetes.io/name=zrok-controller -o jsonpath='{.items[0].metadata.name}')
          if [[ -n "$ZROK_CTRL_POD" ]]; then
            echo "Zrok controller pod: $ZROK_CTRL_POD"
            miniziti kubectl logs -n zrok "$ZROK_CTRL_POD" --tail=50 || echo "Failed to get zrok controller logs"
          else
            echo "WARNING: No zrok controller pod found"
          fi
          
          echo ""
          echo "=========================================="
          echo "Zrok Frontend Logs (Before Upgrade)"
          echo "=========================================="
          
          # Get zrok frontend logs
          ZROK_FRONTEND_POD=$(miniziti kubectl get pods -n zrok -l app.kubernetes.io/name=zrok-frontend -o jsonpath='{.items[0].metadata.name}')
          if [[ -n "$ZROK_FRONTEND_POD" ]]; then
            echo "Zrok frontend pod: $ZROK_FRONTEND_POD"
            miniziti kubectl logs -n zrok "$ZROK_FRONTEND_POD" --tail=50 || echo "Failed to get zrok frontend logs"
          else
            echo "WARNING: No zrok frontend pod found"
          fi

      - name: Create test values directory
        run: |
          mkdir -p testvalues
          cat > testvalues/httpbin.yaml <<EOF
          debug: true
          EOF

      - name: Upgrade miniziti with charts from this branch
        run: miniziti start --no-hosts --verbose --charts ./charts --values-dir ./testvalues
        env:
          MINIZITI_TIMEOUT_SECS: 300

      - name: Find miniziti ingress zone (current)
        id: ingress_zone
        run: |
          echo "ingress_zone=$(miniziti kubectl get configmap miniziti-config -n ${ZITI_NAMESPACE} -o jsonpath='{.data.ingress-zone}')" >> $GITHUB_OUTPUT

      - name: Find the ziti admin password (current)
        id: get_ziti_pwd
        run: |
          miniziti kubectl get secrets "ziti-controller-admin-secret" \
            --output go-template='{{index .data "admin-password" | base64decode }}' \
            | xargs -Iadmin_password echo "ZITI_PWD=admin_password" >> $GITHUB_OUTPUT

      - name: Query Loki for post-upgrade hook logs
        if: steps.mode.outputs.run_baseline == 'true'
        shell: bash
        run: |
          echo "=========================================="
          echo "HTTPBin Post-Upgrade Hook (from Loki)"
          echo "=========================================="
          
          # Reuse existing port-forward (already running from previous step)
          # Query Loki for hook logs
          RESPONSE=$(curl -s "http://localhost:3100/loki/api/v1/query_range" \
            --data-urlencode "query={namespace=\"${ZITI_NAMESPACE}\",pod=~\".*post-upgrade.*\"}" \
            --data-urlencode "start=$(date -u -d '10 minutes ago' +%s)000000000" \
            --data-urlencode "end=$(date -u +%s)000000000")
          
          echo "DEBUG: Loki response:"
          echo "$RESPONSE" | jq '.' || echo "Failed to parse JSON: $RESPONSE"
          
          # Extract log lines
          echo ""
          echo "Log lines:"
          echo "$RESPONSE" | jq -r '.data.result[].values[][1]' 2>/dev/null || echo "No logs found or failed to parse"
          
          echo ""
          echo "=========================================="
          echo "HTTPBin Application Logs (After Upgrade)"
          echo "=========================================="
          
          # Wait for httpbin to restart and initialize after upgrade
          echo "Waiting 10 seconds for httpbin to initialize after upgrade..."
          sleep 10
          
          # Get httpbin pod logs
          HTTPBIN_POD=$(miniziti kubectl get pods -n ${ZITI_NAMESPACE} -l app.kubernetes.io/name=httpbin -o jsonpath='{.items[0].metadata.name}')
          if [[ -n "$HTTPBIN_POD" ]]; then
            echo "HTTPBin pod: $HTTPBIN_POD"
            miniziti kubectl logs -n ${ZITI_NAMESPACE} "$HTTPBIN_POD" --tail=50 || echo "Failed to get httpbin logs"
          else
            echo "WARNING: No httpbin pod found"
          fi

      - name: Stop Loki port-forward
        if: always()
        shell: bash
        run: |
          if [[ -n "${LOKI_PID:-}" ]]; then
            kill $LOKI_PID || true
            echo "Stopped Loki port-forward (PID: $LOKI_PID)"
          fi

      - name: Verify the Console is Available
        shell: bash
        run: |
          set -euo pipefail
          curl -skSfw '%{http_code}\t%{url}\n' -o/dev/null \
          https://miniziti-controller.${{ steps.ingress_zone.outputs.ingress_zone }}/zac/

      - name: Enroll client identity (current charts)
        if: steps.mode.outputs.run_baseline != 'true'
        run: >
          ziti edge enroll
          --jwt ~/.local/state/miniziti/profiles/${ZITI_NAMESPACE}/identities/${ZITI_NAMESPACE}-client.jwt
          --out ~/.local/state/miniziti/profiles/${ZITI_NAMESPACE}/identities/${ZITI_NAMESPACE}-client.json

      - name: Run client proxy (current charts)
        if: steps.mode.outputs.run_baseline != 'true'
        run: >
          nohup ziti tunnel proxy "httpbin-service:4321"
          --identity ~/.local/state/miniziti/profiles/${ZITI_NAMESPACE}/identities/${ZITI_NAMESPACE}-client.json
          --verbose </dev/null &>/tmp/miniziti-client.log &

      - name: Wait for proxy to serve the httpbin service (after upgrade)
        id: wait_for_proxy_upgrade
        continue-on-error: true
        uses: iFaxity/wait-on-action@v1
        with:
          resource: http://127.0.0.1:4321/get
          delay: 1000
          interval: 1000
          timeout: 20000

      - name: Send a POST request to the httpbin service (after upgrade)
        id: test_httpbin_upgrade
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          curl -sSf -XPOST -F ziti=awesome http://127.0.0.1:4321/post > /tmp/httpbin-response-upgrade.json
          AWESOME=$(jq -r '.form.ziti[0]' /tmp/httpbin-response-upgrade.json)
          if [[ "$AWESOME" == "awesome" ]]; then
            echo "✓ Ziti is awesome (after upgrade)!"
          else
            echo "✗ Got '$AWESOME' instead of 'awesome'" >&2
            exit 1
          fi

      - name: Upgrade the zrok chart from the current branch and run the test job
        shell: bash
        env:
          ZITI_MGMT_API_HOST: miniziti-controller.${{ steps.ingress_zone.outputs.ingress_zone }}
          ZITI_PWD: ${{ steps.get_ziti_pwd.outputs.ZITI_PWD }}
          ZROK_DNS_ZONE: ${{ steps.ingress_zone.outputs.ingress_zone }}
        run: |
          helm upgrade \
            --install \
            --namespace zrok --create-namespace \
            --values ./charts/zrok/values-ingress-nginx.yaml \
            --set "ziti.advertisedHost=${ZITI_MGMT_API_HOST}" \
            --set "ziti.password=${ZITI_PWD}" \
            --set "dnsZone=${ZROK_DNS_ZONE}" \
            --set "controller.ingress.hosts[0]=zrok.${ZROK_DNS_ZONE}" \
            --set "test.enabled=true" \
            zrok ./charts/zrok

      - name: Check zrok test job result
        shell: bash
        run: |
          miniziti kubectl -n zrok wait --for=condition=complete --timeout=180s job/zrok-test-job

      - name: Print debug info
        if: always()
        shell: bash
        run: |
          set +e
          set -x
          
          echo "=========================================="
          echo "Kubernetes Resources Overview"
          echo "=========================================="
          miniziti kubectl get pods -A
          miniziti kubectl get services -A
          miniziti kubectl get ingresses -A
          miniziti kubectl get secrets -n ${ZITI_NAMESPACE}
          
          echo ""
          echo "=========================================="
          echo "HTTPBin Pod Details"
          echo "=========================================="
          miniziti kubectl get pods -n ${ZITI_NAMESPACE} -l app.kubernetes.io/name=httpbin -o wide
          miniziti kubectl describe pod -n ${ZITI_NAMESPACE} -l app.kubernetes.io/name=httpbin
          
          echo ""
          echo "=========================================="
          echo "HTTPBin Identity Secret Analysis"
          echo "=========================================="
          
          # Get the base64-encoded identity JSON from the secret
          IDENTITY_B64=$(miniziti kubectl get secret -n ${ZITI_NAMESPACE} miniziti-httpbin-identity -o jsonpath='{.data.ziti_identity_json}')
          
          echo "Secret data keys:"
          miniziti kubectl get secret -n ${ZITI_NAMESPACE} miniziti-httpbin-identity -o jsonpath='{.data}' | jq -r 'keys'
          
          echo ""
          echo "Base64-encoded identity length: ${#IDENTITY_B64} characters"
          
          # Check if secret data is empty
          if [[ -z "$IDENTITY_B64" ]]; then
            echo "✗ WARNING: Secret data is empty! Identity was not created or enrolled."
            echo "  This explains why httpbin cannot bind to the service."
          else
            # Decode and validate JSON structure
            echo ""
            echo "Decoding and validating identity JSON..."
            IDENTITY_JSON=$(echo "$IDENTITY_B64" | base64 -d)
            
            echo "Decoded JSON length: ${#IDENTITY_JSON} characters"
            
            # Validate it's valid JSON (non-empty)
            if [[ -z "$IDENTITY_JSON" ]]; then
              echo "✗ WARNING: Decoded identity is empty!"
            elif echo "$IDENTITY_JSON" | jq empty 2>/dev/null; then
              echo "✓ Valid JSON structure"
              
              # Check for Ziti identity structure
              echo ""
              echo "Ziti identity structure validation:"
              echo "  Top-level keys: $(echo "$IDENTITY_JSON" | jq -r 'keys | join(", ")')"
              
              # Check for required Ziti identity fields
              HAS_ID=$(echo "$IDENTITY_JSON" | jq 'has("id")')
              HAS_ZTAPI=$(echo "$IDENTITY_JSON" | jq 'has("ztAPI")')
              echo "  Has 'id' key: $HAS_ID"
              echo "  Has 'ztAPI' key: $HAS_ZTAPI"
              
              if [[ "$HAS_ID" == "true" ]]; then
                echo ""
                echo "  'id' object keys: $(echo "$IDENTITY_JSON" | jq -r '.id | keys | join(", ")')"
                
                # Check for nested certificate components
                HAS_CERT=$(echo "$IDENTITY_JSON" | jq 'has("id") and (.id | has("cert"))')
                HAS_KEY=$(echo "$IDENTITY_JSON" | jq 'has("id") and (.id | has("key"))')
                HAS_CA=$(echo "$IDENTITY_JSON" | jq 'has("id") and (.id | has("ca"))')
                
                echo "  Has 'id.cert': $HAS_CERT"
                echo "  Has 'id.key': $HAS_KEY"
                echo "  Has 'id.ca': $HAS_CA"
                
                # Show cert/key formats (first few chars to confirm PEM format)
                if [[ "$HAS_CERT" == "true" ]]; then
                  CERT_START=$(echo "$IDENTITY_JSON" | jq -r '.id.cert' | head -c 30)
                  echo "  Certificate starts with: $CERT_START"
                fi
                
                if [[ "$HAS_KEY" == "true" ]]; then
                  KEY_START=$(echo "$IDENTITY_JSON" | jq -r '.id.key' | head -c 30)
                  echo "  Key starts with: $KEY_START"
                fi
              else
                echo "  ✗ WARNING: Missing 'id' key - not a valid Ziti identity!"
              fi
            else
              echo "✗ WARNING: Invalid JSON - parsing failed!"
              echo "First 500 chars: $IDENTITY_JSON" | head -c 500
            fi
          fi
          
          echo ""
          echo "=========================================="
          echo "HTTPBin Pod Environment Variables"
          echo "=========================================="
          HTTPBIN_POD=$(miniziti kubectl get pods -n ${ZITI_NAMESPACE} -l app.kubernetes.io/name=httpbin -o jsonpath='{.items[0].metadata.name}')
          if [[ -n "$HTTPBIN_POD" ]]; then
            # Use kubectl to get env vars from pod spec (distroless image doesn't have grep)
            echo "Environment variables from pod spec:"
            miniziti kubectl get pod -n ${ZITI_NAMESPACE} "$HTTPBIN_POD" -o jsonpath='{range .spec.containers[0].env[*]}{.name}{"="}{.value}{"\n"}{end}'
          fi
          
          echo ""
          echo "=========================================="
          echo "NOTE: Hook logs captured in earlier steps"
          echo "  - Post-install hook: after initial deployment"
          echo "  - Post-upgrade hook: after branch upgrade"
          echo "  Hooks are deleted after completion, so they"
          echo "  must be captured immediately after each deploy."
          echo "=========================================="
          
          echo ""
          echo "=========================================="
          echo "Ziti Controller Logs (last 100 lines)"
          echo "=========================================="
          miniziti kubectl logs --selector app.kubernetes.io/component=ziti-controller --tail=100
          
          echo ""
          echo "=========================================="
          echo "Ziti Router Logs (last 100 lines)"
          echo "=========================================="
          miniziti kubectl logs --selector app.kubernetes.io/component=ziti-router --tail=100
          
          echo ""
          echo "=========================================="
          echo "HTTPBin Pod Logs (FULL - Time Separated)"
          echo "=========================================="
          sleep 2  # Give logs time to settle
          miniziti kubectl logs --selector app.kubernetes.io/name=httpbin --tail=-1
          
          echo ""
          echo "=========================================="
          echo "Miniziti Client Proxy Logs"
          echo "=========================================="
          cat /tmp/miniziti-client.log
          
          echo ""
          echo "=========================================="
          echo "JWT Files"
          echo "=========================================="
          cat ~/.local/state/miniziti/profiles/miniziti/identities/*.jwt || true
          
          echo ""
          echo "=========================================="
          echo "Ziti Network Configuration"
          echo "=========================================="
          # Login to Ziti and check service policies and terminators
          miniziti login
          
          echo ""
          echo "--- Service Policy Advisor ---"
          ziti edge policy-advisor services --quiet httpbin-service
          
          echo ""
          echo "--- Terminators ---"
          ziti edge list terminators
          
          echo ""
          echo "--- Identities ---"
          ziti edge list identities
          
          echo ""
          echo "--- Service Policies ---"
          ziti edge list service-policies
          
          echo ""
          echo "--- Services ---"
          ziti edge list services
          
          echo ""
          echo "=========================================="
          echo "Zrok Logs"
          echo "=========================================="
          miniziti kubectl logs --selector app.kubernetes.io/name=zrok-controller -n zrok -c zrok-bootstrap --tail=-1 || true
          miniziti kubectl logs --selector app.kubernetes.io/name=zrok-controller -n zrok -c zrok --tail=-1 || true
          miniziti kubectl logs --selector app.kubernetes.io/name=zrok-frontend -n zrok -c zrok-bootstrap-frontend --tail=-1 || true
          miniziti kubectl logs --selector app.kubernetes.io/name=zrok-frontend -n zrok -c zrok-frontend --tail=-1 || true
          miniziti kubectl -n zrok logs job/zrok-test-job || true
          
          exit 0
